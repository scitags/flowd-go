//go:build linux

package ebpf

import (
	"testing"

	"github.com/florianl/go-tc/core"
	"golang.org/x/sys/unix"
)

func TestCreateNetlinkClient(t *testing.T) {
	cli, err := NewNetlinkClient()
	if err != nil {
		t.Fatalf("error creating a netlink client: %v", err)
	}

	if err := cli.Close(false); err != nil {
		t.Fatalf("error closing the netlink client: %v", err)
	}
}

func TestCreateQdisc(t *testing.T) {
	cli, err := NewNetlinkClient()
	if err != nil {
		t.Fatalf("error getting a netlink client: %v", err)
	}
	defer cli.Close(false)

	if err := cli.CreateFilterQdisc("lo"); err != nil {
		t.Fatalf("error creating the qdisc: %v", err)
	}

	if l := len(cli.qdiscs); l != 1 {
		t.Fatalf("len(cli.qdiscs) == %d != 1", l)
	}

	if n := cli.qdiscs[0]; n != "lo" {
		t.Fatalf("cli.qdiscs[0] == %q != 'lo'", n)
	}
}

func TestRemoveQdisc(t *testing.T) {
	cli, err := NewNetlinkClient()
	if err != nil {
		t.Fatalf("error getting a netlink client: %v", err)
	}
	defer cli.Close(false)

	// fake the expected state
	cli.qdiscs = []string{"lo"}

	if err := cli.RemoveFilterQdisc("lo"); err != nil {
		t.Fatalf("error creating the qdisc: %v", err)
	}

	if l := len(cli.qdiscs); l != 0 {
		t.Fatalf("len(cli.qdiscs) == %d != 0", l)
	}
}

func TestMacroTC_H_MAKE(t *testing.T) {
	// Value 0x300 is what's generated by libbpf!
	if core.BuildHandle(0, (unix.ETH_P_ALL&0xFF)<<8|(unix.ETH_P_ALL&0xFF00)>>8) != 0x300 {
		t.Errorf("expected BuildHandle to return 0x300...")
	}
}
